// lib/codegen/CodeGenerator.ts

import { Sheet } from '@/lib/simulationEngine'
import { ModelFlattener } from './ModelFlattener'
import { HeaderGenerator } from './HeaderGenerator'
import { InitFunctionGenerator } from './InitFunctionGenerator'
import { StepFunctionGenerator } from './StepFunctionGenerator'
import { AlgebraicEvaluator } from './AlgebraicEvaluator'
import { IntegrationOrchestrator } from './IntegrationOrchestrator'
import { EnableEvaluator } from './EnableEvaluator'
import { RK4Generator } from './RK4Generator'
import { CCodeBuilder } from './CCodeBuilder'
import { CodeGenerationValidator } from './CodeGenerationValidator'
import { TypePropagator } from './TypePropagator'
/**
 * Options for code generation
 */
export interface CodeGenerationOptions {
  /** Model name (defaults to 'model') */
  modelName?: string
  
  /** Whether to generate enable tracking code */
  generateEnableTracking?: boolean
  
  /** Whether to include debug comments */
  includeDebugComments?: boolean
  
  /** Whether to generate a main() function for testing */
  generateMain?: boolean
}

/**
 * Result of code generation
 */
export interface CodeGenerationResult {
  /** Generated header file content */
  header: string
  
  /** Generated source file content */
  source: string
  
  /** Any warnings generated during code generation */
  warnings: string[]
  
  /** Statistics about the generated code */
  stats: {
    blocksProcessed: number
    connectionsProcessed: number
    subsystemsFlattened: number
    statesGenerated: number
    enabledSubsystems: number
  }
}

/**
 * Main code generator that coordinates all sub-generators
 */
export class CodeGenerator {
  private options: Required<CodeGenerationOptions>
  
  constructor(options: CodeGenerationOptions = {}) {
    this.options = {
      modelName: options.modelName || 'model',
      generateEnableTracking: options.generateEnableTracking ?? true,
      includeDebugComments: options.includeDebugComments ?? true,
      generateMain: options.generateMain ?? false
    }
  }
  
  /**
   * Generate C code from model sheets
   */
  generate(sheets: Sheet[]): CodeGenerationResult {
    // Step 1: Flatten the model
    const flattener = new ModelFlattener({
      preserveOriginalNames: this.options.includeDebugComments,
      generateEnableTracking: this.options.generateEnableTracking,
      namePrefix: '',
      nameSeparator: '_'
    })
    
    const flatteningResult = flattener.flattenModel(sheets, this.options.modelName)
    const model = flatteningResult.model
    
    // Step 2: Validate the flattened model
    const validator = new CodeGenerationValidator()
    const validationResult = validator.validate(model)
    
    // Combine warnings from flattening and validation
    const allWarnings = [
      ...flatteningResult.warnings,
      ...validationResult.warnings.map(w => w.message)
    ]
    
    // Check for validation errors
    if (!validationResult.valid) {
      // Filter out known flattening artifacts from errors
      const realErrors = validationResult.errors.filter(e => {
        // Skip connection errors for subsystem-generated connections
        if (e.code === 'INVALID_CONNECTION' && e.details?.connectionId) {
          const connId = e.details.connectionId as string
          // These are generated by the flattening process
          if (connId.includes('_enable') || connId.includes('_wire')) {
            return false
          }
        }
        return true
      })
      
      if (realErrors.length > 0) {
        // Still generate code but include error comments
        const errorMessages = realErrors.map(e => 
          `ERROR: ${e.message} (${e.code})`
        )
        allWarnings.push(...errorMessages)
        
        console.error('Code generation validation errors:', realErrors)
      }
    }
    
    // Step 3: Propagate types through the model
    const typePropagator = new TypePropagator(model)
    const typeMap = typePropagator.propagate()
    
    // Step 4: Generate header file
    const headerGenerator = new HeaderGenerator(model, typeMap)
    const header = headerGenerator.generate()
    
    // Step 5: Generate source file
    const source = this.generateSource(model, typeMap)
    
    // Step 6: Collect statistics
    const stats = {
      blocksProcessed: model.blocks.length,
      connectionsProcessed: model.connections.length,
      subsystemsFlattened: model.metadata.subsystemCount,
      statesGenerated: this.countStates(model),
      enabledSubsystems: model.subsystemEnableInfo.filter(info => info.hasEnableInput).length
    }
    
    return {
      header,
      source,
      warnings: allWarnings,
      stats
    }
  }
  
  /**
   * Generate the source file
   */
  private generateSource(model: any, typeMap: Map<string, string>): string {
    const modelName = CCodeBuilder.sanitizeIdentifier(model.metadata.modelName)
    let source = ''
    
    // File header comment
    source += CCodeBuilder.generateCommentBlock([
      `${model.metadata.modelName} - Generated C code`,
      `Generated on: ${new Date().toISOString()}`,
      '',
      'This code was automatically generated from a visual model.',
      'Manual modifications may be overwritten on regeneration.'
    ])
    source += '\n'
    
    // Includes
    source += `#include "${modelName}.h"\n`
    source += '#include <string.h>\n'
    source += '#include <math.h>\n\n'
    
    // Enable state macro if needed
    const enableEvaluator = new EnableEvaluator(model)
    const enableMacro = enableEvaluator.generateEnableCheckMacro()
    if (enableMacro) {
      source += enableMacro
    }
    
    // Static lookup tables and constants
    source += this.generateStaticData(model)
    
    // Init function
    const initGenerator = new InitFunctionGenerator(model)
    source += initGenerator.generate()
    source += '\n'
    
    // Enable evaluation function (if needed)
    const enableEvalCode = enableEvaluator.generate()
    if (enableEvalCode) {
      source += enableEvalCode
      source += '\n'
    }
    
    // Algebraic evaluation function - NEW!
    const algebraicEvaluator = new AlgebraicEvaluator(model, typeMap)
    source += algebraicEvaluator.generate()
    source += '\n'
    
    // RK4 and derivatives functions (if needed)
    const rk4Generator = new RK4Generator(model)
    const rk4Code = rk4Generator.generate()
    
    // Extract just the derivatives function from RK4 code
    const derivativesMatch = rk4Code.match(/\/\*[\s\S]*?Calculate state derivatives[\s\S]*?\n\}\n/)
    if (derivativesMatch) {
      source += derivativesMatch[0]
      source += '\n'
    }
    
    // Step function - now generated by IntegrationOrchestrator
    const integrationOrchestrator = new IntegrationOrchestrator(model)
    let stepCode = integrationOrchestrator.generate()
    
    // Insert RK4 integration into step function
    const rk4IntegrationMatch = rk4Code.match(/static void perform_rk4_integration[\s\S]*?\n\}\n/)
    if (rk4IntegrationMatch) {
      // Add the RK4 function before step
      source += rk4IntegrationMatch[0]
      source += '\n'
      
      // Replace the placeholder in step function
      stepCode = stepCode.replace(
        '    /* TODO: State integration */',
        '    /* Perform RK4 integration for dynamic blocks */\n    perform_rk4_integration(model);'
      )
    }
    
    source += stepCode
    
    // Optional main function
    if (this.options.generateMain) {
      source += '\n'
      source += this.generateMainFunction(model)
    }
    
    return source
  }
  
  /**
   * Generate static data (lookup tables, etc.)
   */
  private generateStaticData(model: any): string {
    let code = ''
    let hasStaticData = false
    
    // Generate lookup tables for 1D and 2D lookup blocks
    for (const block of model.blocks) {
      if (block.block.type === 'lookup_1d') {
        if (!hasStaticData) {
          code += CCodeBuilder.generateCommentBlock(['Static lookup tables'])
          hasStaticData = true
        }
        
        code += this.generate1DLookupTable(block)
      } else if (block.block.type === 'lookup_2d') {
        if (!hasStaticData) {
          code += CCodeBuilder.generateCommentBlock(['Static lookup tables'])
          hasStaticData = true
        }
        
        code += this.generate2DLookupTable(block)
      }
    }
    
    if (hasStaticData) {
      code += '\n'
    }
    
    return code
  }
  
  /**
   * Generate 1D lookup table
   */
  private generate1DLookupTable(block: any): string {
    const safeName = CCodeBuilder.sanitizeIdentifier(block.block.name)
    const params = block.block.parameters || {}
    const inputValues = params.inputValues || [0, 1]
    const outputValues = params.outputValues || [0, 1]
    
    let code = `/* Lookup table for ${block.flattenedName} */\n`
    code += `static const double ${safeName}_inputs[] = ${CCodeBuilder.generateArrayInitializer(inputValues)};\n`
    code += `static const double ${safeName}_outputs[] = ${CCodeBuilder.generateArrayInitializer(outputValues)};\n`
    code += `static const int ${safeName}_size = ${inputValues.length};\n\n`
    
    return code
  }
  
  /**
   * Generate 2D lookup table
   */
  private generate2DLookupTable(block: any): string {
    const safeName = CCodeBuilder.sanitizeIdentifier(block.block.name)
    const params = block.block.parameters || {}
    const input1Values = params.input1Values || [0, 1]
    const input2Values = params.input2Values || [0, 1]
    const outputTable = params.outputTable || [[0, 0], [0, 0]]
    
    let code = `/* 2D Lookup table for ${block.flattenedName} */\n`
    code += `static const double ${safeName}_input1[] = ${CCodeBuilder.generateArrayInitializer(input1Values)};\n`
    code += `static const double ${safeName}_input2[] = ${CCodeBuilder.generateArrayInitializer(input2Values)};\n`
    code += `static const int ${safeName}_size1 = ${input1Values.length};\n`
    code += `static const int ${safeName}_size2 = ${input2Values.length};\n`
    
    // Generate 2D table
    code += `static const double ${safeName}_table[${input1Values.length}][${input2Values.length}] = {\n`
    for (let i = 0; i < outputTable.length; i++) {
      code += '    ' + CCodeBuilder.generateArrayInitializer(outputTable[i], false)
      if (i < outputTable.length - 1) code += ','
      code += '\n'
    }
    code += '};\n\n'
    
    return code
  }
  
  /**
   * Generate optional main function for testing
   */
  private generateMainFunction(model: any): string {
    const modelName = CCodeBuilder.sanitizeIdentifier(model.metadata.modelName)
    
    let code = CCodeBuilder.generateCommentBlock([
      'Example main function for testing',
      'This demonstrates basic usage of the generated model'
    ])
    
    code += '#ifdef TEST_MAIN\n\n'
    code += '#include <stdio.h>\n\n'
    
    code += 'int main(void) {\n'
    code += `    ${modelName}_t model;\n`
    code += '    double dt = 0.01; /* 10ms time step */\n'
    code += '    int num_steps = 1000;\n\n'
    
    code += '    /* Initialize model */\n'
    code += `    ${modelName}_init(&model, dt);\n\n`
    
    code += '    /* Set some example inputs */\n'
    const inputPorts = model.blocks.filter((b: any) => b.block.type === 'input_port')
    if (inputPorts.length > 0) {
      code += '    /* TODO: Set actual input values */\n'
      for (const port of inputPorts) {
        const portName = port.block.parameters?.portName || port.block.name
        code += `    model.inputs.${CCodeBuilder.sanitizeIdentifier(portName)} = 0.0;\n`
      }
      code += '\n'
    }
    
    code += '    /* Run simulation */\n'
    code += '    printf("Running simulation...\\n");\n'
    code += '    for (int i = 0; i < num_steps; i++) {\n'
    code += `        ${modelName}_step(&model);\n`
    code += '        \n'
    code += '        /* Print outputs every 100 steps */\n'
    code += '        if (i % 100 == 0) {\n'
    code += '            printf("Time: %.2f", model.time);\n'
    
    const outputPorts = model.blocks.filter((b: any) => b.block.type === 'output_port')
    for (const port of outputPorts) {
      const portName = port.block.parameters?.portName || port.block.name
      const safeName = CCodeBuilder.sanitizeIdentifier(portName)
      code += `            printf(", ${portName}: %.4f", model.outputs.${safeName});\n`
    }
    
    code += '            printf("\\n");\n'
    code += '        }\n'
    code += '    }\n\n'
    
    code += '    printf("Simulation complete.\\n");\n'
    code += '    return 0;\n'
    code += '}\n\n'
    code += '#endif /* TEST_MAIN */\n'
    
    return code
  }
  
  /**
   * Count number of state variables in the model
   */
  private countStates(model: any): number {
    let count = 0
    
    for (const block of model.blocks) {
      if (block.block.type === 'transfer_function') {
        const denominator = block.block.parameters?.denominator || [1, 1]
        const stateOrder = Math.max(0, denominator.length - 1)
        
        if (stateOrder > 0) {
          // Check if vector/matrix
          const outputType = block.block.parameters?.dataType || 'double'
          const arrayMatch = outputType.match(/\[(\d+)\]/)
          
          if (arrayMatch) {
            count += stateOrder * parseInt(arrayMatch[1])
          } else {
            count += stateOrder
          }
        }
      }
    }
    
    return count
  }
}